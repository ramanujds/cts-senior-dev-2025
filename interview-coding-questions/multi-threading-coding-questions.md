### 1. Create a Thread Using Both `Thread` Class and `Runnable` Interface

- Write programs to create and start threads using both methods.

***

### 2. Implement a Thread-Safe Counter

- Design a counter class accessed by multiple threads without race conditions.
- Use synchronization or atomic variables.

***

### 3. Producer-Consumer Problem Using `BlockingQueue`

- Implement producer and consumer threads communicating via a thread-safe queue.

***

### 4. Demonstrate Deadlock with Multiple Threads

- Write code that produces a deadlock scenario involving at least two locks.

***

### 5. Fix the Deadlock Problem

- Modify the above deadlock example to avoid deadlock using lock ordering or `tryLock()`.

***

### 6. Use `CompletableFuture` to Execute Multiple Tasks Asynchronously and Combine Results

- Run two independent tasks in parallel and combine their results.

***

### 7. Implement a Thread-Safe Singleton Using Double-Checked Locking

- Make sure the singleton is properly synchronized.

***

### 8. Create a Custom Thread Pool

- Implement a basic thread pool executor that manages a fixed number of threads.

***

### 9. Write a Program to Demonstrate `wait()`, `notify()`, and `notifyAll()` Mechanisms

- Show how threads communicate using object monitors.

***


### 10. Explain and Demonstrate use of `volatile` Keyword with Example

- Show visibility issues solved by `volatile`.

***

### 11. Count the Number of Occurrences of Words in Parallel Using Streams

***

### 12. Use `ReentrantLock` and Condition to Synchronize Access to a Shared Resource

